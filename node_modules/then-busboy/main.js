"use strict";
var Busboy, FieldsLimitException, FilesLimitException, IncomingMessage, PartsLimitException, UnallowedMime, assign, checkMime, createReadStream, createWriteStream, defaults, extname, extractKeys, getObjFields, isArray, isBoolean, isEmpty, isPlainObject, mapListeners, merge, reduceRight, reducer, ref, ref1, ref2, rescueObjStruct, rescueTypes, shortid, thenBusboy, tmpDir, tmpdir, typeIs,
  slice = Array.prototype.slice;

Busboy = require("busboy");

shortid = require("shortid");

extname = require("path").extname;

ref = require("os"), tmpdir = ref.tmpdir, tmpDir = ref.tmpDir;

IncomingMessage = require("http").IncomingMessage;

ref1 = require("fs"), createReadStream = ref1.createReadStream, createWriteStream = ref1.createWriteStream;

isPlainObject = require("lodash.isplainobject");

isBoolean = require("lodash.isboolean");

isEmpty = require("lodash.isempty");

merge = require("lodash.merge");

typeIs = require("type-is");

ref2 = require("./errors"), PartsLimitException = ref2.PartsLimitException, FieldsLimitException = ref2.FieldsLimitException, FilesLimitException = ref2.FilesLimitException, UnallowedMime = ref2.UnallowedMime;

isArray = Array.isArray;

assign = Object.assign;

reduceRight = function() {
  var args, arr;
  arr = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
  return Array.prototype.reduceRight.apply(arr, args);
};

tmpdir || (tmpdir = tmpDir);

defaults = {
  split: false,
  mimes: {
    ignoreUnallowed: false,
    allowed: null
  }
};


/*
 * @api private
 */

mapListeners = function(listeners, fn, ctx) {
  var handler, name;
  for (name in listeners) {
    handler = listeners[name];
    fn.call(ctx, name, handler);
  }
};


/*
 * Trying to rescue field value actual type from string
 *
 * @param string value
 *
 * @api private
 */

rescueTypes = function(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (value === "null") {
    return null;
  }
  if (value === "false") {
    return false;
  }
  if (value === "true") {
    return true;
  }
  if (value !== "" && !isNaN(value)) {
    return Number(value);
  }
  return value;
};


/*
 * Rescue target object structure
 *
 * @param object obj
 * @param object target
 *
 * @return object
 *
 * @api private
 */

rescueObjStruct = function(obj, target) {
  var key, res, val;
  key = Object.keys(obj)[0];
  val = obj[key];
  res = isNaN(key) ? {} : [];
  if (isPlainObject(target) && key in target) {
    res[key] = rescueObjStruct(val, target[key]);
  } else if (isArray(target)) {
    res = slice.call(target);
    if (!res[key] || Number(key)) {
      if (isPlainObject(val)) {
        res[key] = rescueObjStruct(val, res[key]);
      } else {
        res[key] = val;
      }
    } else {
      if (isPlainObject(val)) {
        res = rescueObjStruct(val, res[key]);
      } else {
        res.push(val);
      }
    }
  } else {
    res[key] = val;
  }
  return merge(target, res);
};


/*
 * Extract keys from fieldname
 *
 * @param string str
 *
 * @return array
 *
 * @api private
 */

extractKeys = function(str) {
  if (!str.includes("[")) {
    return str;
  }
  return str.split("[").map(function(v) {
    return v.replace("]", "");
  });
};


/*
 * Just a callback for Array#reduceRight method
 *
 * @param any prev
 * @param any next
 *
 * @api private
 */

reducer = function(prev, next) {
  var arr, obj1;
  if (("" + (Number(next))) === "NaN") {
    return (
      obj1 = {},
      obj1["" + next] = prev,
      obj1
    );
  } else {
    arr = [];
    arr[Number(next)] = prev;
    return arr;
  }
};


/*
 * @param object target
 * @param string fieldname
 * @param any value
 *
 * @api private
 */

getObjFields = function(target, fieldname, value) {
  var keys, res;
  keys = extractKeys(fieldname);
  if (typeof keys === "string") {
    if (("" + (Number(keys))) !== "NaN") {
      throw new TypeError("Top-level field name must be a string");
    }
    target[fieldname] = rescueTypes(value);
    return target;
  }
  res = reduceRight(keys, reducer, rescueTypes(value));
  target = rescueObjStruct(res, target);
  return target;
};


/*
 * Check if current mime is allowed
 *
 * @param string current
 * @param object allowed
 */

checkMime = function(current, allowed) {
  var group, k, ref3, type, v;
  if (isEmpty(allowed)) {
    return true;
  }
  if (isArray(allowed)) {
    return !!typeIs.is(current, allowed);
  }
  ref3 = current.split("/"), group = ref3[0], type = ref3[1];
  for (k in allowed) {
    v = allowed[k];
    if (!isArray(v)) {
      v = [v];
    }
    return group === k && v.includes(type);
  }
};


/*
 * Promise-based wrapper around Busboy, inspired by async-busboy
 *
 * @param http.IncomingMessage req
 * @param boolean|object
 *
 * @return Promise
 *
 * @api public
 */

thenBusboy = function(req, op) {
  if (op == null) {
    op = {};
  }
  return new Promise(function(resolve, reject) {
    var allowed, bb, fields, files, ignoreUnallowed, listeners, mimes, onField, onFieldsLimit, onFile, onFilesLimit, onPartsLimit;
    if (!(req instanceof IncomingMessage)) {
      throw new TypeError("Request parameter must be an instance of http.IncomingMessage.");
    }
    if (isBoolean(op)) {
      op = {
        split: op
      };
    }
    if (!isPlainObject(op)) {
      throw new TypeError("Options argument must be a plain object.");
    }
    op = assign({}, defaults, op);
    mimes = op.mimes;
    if (typeof mimes === "string") {
      mimes = [mimes];
    }
    if (isArray(mimes)) {
      mimes = assign({}, defaults.mimes, {
        allowed: mimes
      });
    }
    if (!isPlainObject(mimes)) {
      throw new TypeError("The \"mimes\" parameter should be a plain object.");
    }
    if (("ignoreUnallowed" in mimes) === false && ("allowed" in mimes) === false) {
      mimes = assign({}, defaults.mimes, {
        allowed: mimes
      });
    }
    if (!("ignoreUnallowed" in mimes)) {
      mimes = assign({}, defaults.mimes, mimes);
    }
    allowed = mimes.allowed, ignoreUnallowed = mimes.ignoreUnallowed;
    fields = {};
    files = {};
    bb = new Busboy(assign({}, {
      headers: req.headers
    }, op));
    onField = function(name, value) {
      var err;
      try {
        return fields = getObjFields(fields, name, value);
      } catch (error) {
        err = error;
        return reject(err);
      }
    };
    onFile = function(fieldname, stream, filename, enc, mime) {
      var isAllowed, onFileStreamEnd, tmpPath;
      isAllowed = checkMime(mime, allowed);
      if (ignoreUnallowed === false && isAllowed === false) {
        return reject(new UnallowedMime("Unknown mime type: " + mime));
      }
      if (!isAllowed) {
        return stream.emit("end");
      }
      tmpPath = (tmpdir()) + "/" + (shortid()) + (extname(filename));
      onFileStreamEnd = function() {
        var err, file;
        file = createReadStream(tmpPath);
        file.originalName = filename;
        file.enc = enc;
        file.mime = mime;
        try {
          return files = getObjFields(files, fieldname, file);
        } catch (error) {
          err = error;
          return reject(err);
        }
      };
      return stream.on("end", onFileStreamEnd).pipe(createWriteStream(tmpPath));
    };
    onPartsLimit = function() {
      return reject(new PartsLimitException("Parts limit reached"));
    };
    onFieldsLimit = function() {
      return reject(new FieldsLimitException("Fields limit reached"));
    };
    onFilesLimit = function() {
      return reject(new FilesLimitException("Files limit reached"));
    };
    listeners = {
      error: reject,
      field: onField,
      file: onFile,
      partsLimit: onPartsLimit,
      filesLimit: onFilesLimit,
      fieldsLimit: onFieldsLimit,
      finish: function() {
        mapListeners(listeners, bb.removeListener, bb);
        resolve(op.split ? {
          fields: fields,
          files: files
        } : merge({}, fields, files));
      }
    };
    mapListeners(listeners, bb.on, bb);
    req.pipe(bb);
  });
};

module.exports = exports["default"] = thenBusboy;

//# sourceMappingURL=main.js.map
